<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法：二分查找]]></title>
    <url>%2F2021%2F11%2F26%2Fsearch-position%2F</url>
    <content type="text"><![CDATA[搜索插入位置题目链接https://leetcode-cn.com/problems/search-insert-position/ 题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 示例 4: 输入: nums = [1,3,5,6], target = 0 输出: 0 示例 5: 输入: nums = [1], target = 0 输出: 0 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 为无重复元素的升序排列数组 -104 &lt;= target &lt;= 104 解题思路 标签：二分查找 如果该题目暴力解决的话需要 O(n) 的时间复杂度，但是如果二分的话则可以降低到 O(logn) 的时间复杂度 整体思路和普通的二分查找几乎没有区别，先设定左侧下标 left 和右侧下标 right，再计算中间下标 mid 每次根据 nums[mid] 和 target 之间的大小进行判断，相等则直接返回下标，nums[mid] &lt; target 则 left 右移，nums[mid] &gt; target 则 right 左移 查找结束如果没有相等值则返回 left，该值为插入位置 时间复杂度：O(logn) 代码 1234567891011121314151617public class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length -1; while (left &lt;= right) &#123; int mid = left + (right -left) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else &#123; right = right -1; &#125; &#125; return left; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找第一个错误版本]]></title>
    <url>%2F2021%2F11%2F19%2Ffirst-version%2F</url>
    <content type="text"><![CDATA[第一个错误的版本题目链接https://leetcode-cn.com/problems/first-bad-version/ 题目描述你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例 1: 输入：n = 5, bad = 4 输出：4 解释： 调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true 所以，4 是第一个错误的版本。 示例 2: 输入：n = 1, bad = 1 输出：1 提示： 1 &lt;= bad &lt;= n &lt;= 231 - 1 解题思路因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。 注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。 具体地，将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。 这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧 O(logn) 次。 代码123456789101112131415161718/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int left = 1, right = n; while (left &lt; right) &#123; // 循环直至区间左右端点相同 int mid = left + (right - left) / 2; // 防止计算时溢出 if (isBadVersion(mid)) &#123; right = mid; // 答案在区间 [left, mid] 中 &#125; else &#123; left = mid + 1; // 答案在区间 [mid+1, right] 中 &#125; &#125; // 此时有 left == right，区间缩为一个点，即为答案 return left; &#125;&#125; 复杂度分析 时间复杂度：O(\log n)O(logn)，其中 nn 是给定版本的数量。 空间复杂度：O(1)O(1)。我们只需要常数的空间保存若干变量。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：二分查找]]></title>
    <url>%2F2021%2F11%2F18%2Fbinary-search-md%2F</url>
    <content type="text"><![CDATA[二分查找题目链接https://leetcode-cn.com/problems/binary-search/ 题目描述给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示: 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题思路 标签：二分查找 过程 设定左右指针 找出中间位置，并判断该位置值是否等于 target nums[mid] == target 则返回该位置下标 nums[mid] &gt; target 则右侧指针移到中间 nums[mid] &lt; target 则左侧指针移到中间 时间复杂度：O(logN) 其中 N 是数组的长度。 空间复杂度：O(1)。 基于上述事实，可以在有序数组中使用二分查找寻找目标值。 二分查找的做法是，定义查找的范围 [left,right] ，初始查找范围是整个数组。每次取查找范围的中点 mid，比较 nums[mid] 和 target 的大小，如果相等则 mid 即为要寻找的下标，如果不相等则根据 nums[mid] 和 target 的大小关系将查找范围缩小一半。 由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(logn)，其中 n 是数组的长度。 二分查找的条件是查找范围不为空，即 left≤right。如果 target 在数组中，二分查找可以保证找到 target，返回 target 在数组中的下标。如果 target 不在数组中，则当 left&gt;right 时结束查找，返回 -1。 代码123456789101112131415161718192021222324public class Solution &#123; public static void main(String[] args) &#123; Solution test = new Solution(); int[] nums = &#123;-1, 0, 3, 5, 9, 12&#125;; System.out.println(test.search(nums, 9)); &#125; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zeal-setting]]></title>
    <url>%2F2019%2F05%2F20%2Fzeal-setting%2F</url>
    <content type="text"><![CDATA[作为一名程序开发者，翻查文档成为了每天都必须去做的事情。然而，由于使用到的知识和工具不相同，所以几乎每次都需要重新打开官网的文档进行搜索，而且不同知识和工具的文档还需要切换浏览器标签来浏览，尤其是不能连接外网或者无网的情况下想要查看一些API就变得十分不方便了。 那么有没有一个工具，即可以让我们方便查阅文档，又可以把自己日常用到的资料存起来的工具呢，下面就来介绍一下 Zeal 这一离线文档工具。Mac机对应软件为：Dash。 关于zeal对于zeal这款软件网上有很多介绍，这儿有一个不错的文章推介给大家，本文就不多加叙说。参考这个链接 Zeal 创建自己专属的文档项目上边推介的文章也有对于Zeal创建自己的专属文档部分，但是苦于自己自己太浅有部分跳跃太快，没看懂，所以自己亲自把步骤分解，进行搭建。同样Zeal 官方也写了一个教我们如何去编写自己的 Docsets 的文档链接，但是该文档写得比较简单，并且没有详细地操作指引，操作起来比较复杂。 Zeal 的 Docsets 其实是 html 的集合，那么我们可以先用文档工具，生成一些静态的 html 文档。然后通过 Docsets 官方提供的 Docsets 生成器来把 html 生成 Docsets，这样就可以生成出属于我们自己的 Docsets 了。 合适的文档生成器目前各种开发语言都有文档生成器，我所知道的 Node.js 生成器就有数十个像 Gitbook、Docsify、Vuepress 等等。但是并不是每一个都适合用来制作 Docsets，举个例子： Docsify 是一个很棒的生成器，但是用于 Docsets 的话就会有问题。原因是因为 Docsify 是通过 js 读取 Markdown 来实现的，而 Zeal 内部是一个浏览器，并没有静态服务器，所以制作出来的 Docsets 会出现跨域的问题。 最终我选择了使用 Gitbook 来制作 Docsets，它能生成静态的 Html 文件，并且能够通过本地双击打开，能够跟 Zeal 完美融合。 编写文档确定了使用 Gitbook 之后，先安装 Gitbook： npm install gitbook-cli -gGitBook 准备工作做好之后，我们进入一个你要写书的目录，输入如下命令。12345$ gitbook initwarn: no summary file in this bookinfo: create README.mdinfo: create SUMMARY.mdinfo: initialization is finished 可以看到他会创建 README.md 和 SUMMARY.md 这两个文件，README.md 应该不陌生，就是说明文档，而 SUMMARY.md 其实就是书的章节目录，其默认内容如下所示：123# Summary* [Introduction](README.md) 接下来，我们输入 $ gitbook serve命令，然后在浏览器地址栏中输入http://localhost:4000 便可预览书籍。效果如下所示： 根据需求创建文件夹和对应的文件，举个栗子，如下格式的目录结构： ├── README.md ├── SUMMARY.md ├── part1 │ ├── README.md │ ├── section1.1.md │ └── section1.2.md └── part2 ├── README.md ├── section2.1.md └── section2.2.md 然后修改SUMMARY.md文件配置书的章节目录，具体如下所示： # Summary * [Introduction](README.md) * [Part I](part1/README.md) * [Writing is nice](part1/section1.1.md) * [GitBook is nice](part1/section1.2.md) * [Part II](part2/README.md) * [We love feedback](part2/section2.1.md) * [Better tools for authors](part2/section2.2.md) 然后运行该命令$ gitbook build后会在书籍的文件夹中生成一个 _book 文件夹, 里面的内容即为生成的 html 文件，此时我们在使用 $ gitbook serve命令就可以提到如下图所示的效果图： 对于gitbook的使用就介绍到这儿，顺便给一个参考链接大家可以看看gitbook的相关文档。 把 html 生成 Docsets有了文档对应的 html 之后，需要把 html 生成 Docsets。我使用 Node.js 生成，在 npm 上面找了一个叫 docset-generator 的插件，使用如下命令进行安装在该项目中安装插件：1$ npm install docset-generator --save 安装完成后会在该目录下面生成一个 node_modules文件夹，以及文件package-lock.json ，然后将package-lock.json 拷贝一份重命名为package.json，最后在同目录下面新建index.js，写入以下代码：123456789101112131415let DocSetGenerator = require(&quot;docset-generator&quot;).DocSetGenerator;let docSetGenerator = new DocSetGenerator(&#123; destination: &quot;./output/&quot;, name: &quot;Micro-Paul&quot;, documentation: &quot;./_book&quot;, icon: &quot;./images/note.png&quot;, entries: [ // entries 可以设置 Docsets 的分类，一般一个分类对应一个 html &#123; name: &quot;个人笔记&quot;, type: &quot;Guide&quot;, path: &quot;./index.html&quot; &#125; ]&#125;);docSetGenerator.create(); 通过命令：1$ node index.js 即可在对应的目录下生成对应的 Docsets。接下来就是最后的一步，把这个文件夹放进 Zeal 里面。在 Zeal 里面有一个叫 docsets 的文件夹，进去之后会看到下载的 docsets 都在里面，把刚刚生成的 docsets 放进去，重启一下 Zeal 就可以看到自己的文档了。如下图所示： 结束语以上就是我在工作过程中，根据自己的开发习惯所做出来的一个小文档，如果大家有其他方便的工具，可以一起讨论一下，有任何问题欢迎骚扰~]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>zeal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot2]]></title>
    <url>%2F2019%2F03%2F28%2Fspring-boot2%2F</url>
    <content type="text"><![CDATA[使用springboot作为微服务开发框架，可以很好地提高开发的效率和保证微服务开发的质量，springboot中嵌入了tomcat,可直接运行一个jar包来发布微服务，此外还提供了一系列“开箱即用”的插件，可大大提高开发的效率，同时也可以去扩展更多的插件。 微服务技术选型在发布微服务时，可连接zookeeper来注册微服务，实现“服务注册”。实际上zookeeper中有一个名为ZNode的内存树状模型，树上的节点用于存放微服务的配置信息。使用Node.js处理浏览器的请求，在Node.js中连接zookeeper，发现服务配置，实现“服务发现”，有大量的Node.js的zookeeper客户端可以完成这个任务。 通过Node.js将请求转发到tomcat上，实现“反向代理”，同样也有大量的Node.js库可供我们自由选择。Node.js的“单线程模型”且“非阻塞异步式I/O”特性，通过“事件循环”的方式来支撑大量的高并发请求，此外Node.js原生也提供了集群特性，可确保高可用性。为了实现微服务自动化部署，我们可通过Jenkins搭建自动化部署系统，并使用Docker将服务进行容器化封装。 综上所述，微服务架构技术选型如下所示。 Springboot：https://spring.io/projects/spring-boot/ZooKeeper: http://zookeeper.apache.org/Node.js: https://nodejs.org/Jenkins: https://jenkins.io/Docker: https://www.docker.com/ 下面通过一张关系图来归纳一下微服务架构技术选型，如下图所示： 使用Jenkins部署服务 使用springboot开发服务 使用Docker封装服务 使用ZooKeeper注册服务 使用Node.js调用服务]]></content>
      <categories>
        <category>语言 - Spring</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot微服务学习（1）]]></title>
    <url>%2F2018%2F11%2F08%2Fspringboot1%2F</url>
    <content type="text"><![CDATA[SpringBoot 作为现在非常火的技术，怎么来说都应该好好学习一下，最近在看《SpringBoot揭秘-快速构建微服务体系》这本书，首先阅读笔记走起一波！！！ 微服务开发规范无论使用传统的应用架构，还是微服务架构，我们都需要定义良好的开发规范。经验表明，我们需要善用代码版本控制系统。就拿Git来说，它很好的支持了多分支代码版本，我们需要利用这个特性来提高开发效率，下图就是一款经典的分支管理规范。 最稳定的代码放在master分支上（相当于SVN的trunk分支），我们不要直接在master分支上提交代码，只能在该分支上进行代码合并操作，例如将其他分支的代码合并到master分支上。我们日常开发中的代码需要从master分支上拉一条develop分支出来，该分支所有人都能访问，但一般情况下，我们也不会直接在该分支上提交代码，代码同样是从其他分支合并到develop分支上的。 当我们需要开发某个特性时，需要从develop分支上拉出一条feature分支，例如feature-1与feature-2，在这些分支上并行地开发具体特性。 当特性开发完毕后，我们决定发布某个版本了，此时需要从develop分支上拉出一条release分支，例如release-1.0.0，并将需要发布的特性从相关feature分支一同合并到release分支上，随后针对release分支部署测试环境，测试工程师在该分支上做功能测试，开发工程师在该分支上修改bug。待测试工程师无法找到任何bug时，我们可将该release分支部署到预发布环境中。再次验证以后，如无任何bug，此时可将release分支部署到生成环境中。待上线完成后，将release分支上的代码同时合并到develop分支与master分支上，并在master分支上打一个tag，例如v1.0.0。 当在生产环境中发现bug时，我们需要从对应的tag上（例如v1.0.0）拉出一条hotfix分支（例如hotfix-1.0.1），并在该分支上进行bug修复。待bug完全修复后，需将hotfix分支上的代码同时合并到develop分支与master分支上。 对于版本号我们也有要求，格式为：x.y.z，其中，x用于有重大重构时才会升级，y用于有新的特性发布时才会升级，z用于修改了某个bug后才会升级。 针对每个服务的开发工作，我们都需要严格按照以上开发规范来执行。]]></content>
      <categories>
        <category>语言 - Spring</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人Linux操作系统分区]]></title>
    <url>%2F2018%2F10%2F24%2FLinux-setting%2F</url>
    <content type="text"><![CDATA[个人Linux操作系统设置，8G的内存，500G的硬盘分区为例Linux分区Linux分区介绍/boot ：用来存放与 Linux 系统启动有关的程序，比如启动引导装载程序等，建议大小为 100MB 。//200M /swap ：实现虚拟内存，建议大小是物理内存的 1~2 倍。//3G /usr ：用来存放 Linux 系统中的应用程序，其相关数据较多，建议大于 3GB 以上。 /var ：用来存放 Linux 系统中经常变化的数据以及日志文件，建议大于 1GB 以上。 /home ：存放普通用户的数据，是普通用户的宿主目录，建议大小为剩下的空间。 / ： Linux 系统的根目录，所有的目录都挂在这个目录下面，建议大小为 5GB 以上。 /tmp ：将临时盘在独立的分区，可避免在文件系统被塞满时影响到系统的稳定性。建议大小为 500MB 以上。 // 个人电脑分区详情常见挂载点的情况说明：一般来说，在linux系统中都有最少两个挂载点，分别是/ (根目录)及 swap（交换分区），其中，/ 是必须的。详细内容见下文： 安装系统时选择creat custom layout 自定义分区建议挂载的几大目录： /home 100G /opt 100G /usr/local 69G /data 80G /var 8G /boot 800M / 100G swap 8G 这就是我的电脑安装Linux（centos）系统时候得详细分区。大家也可以按照自己的实际需求分区，感谢！！！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建（hexo+GitHub）]]></title>
    <url>%2F2018%2F10%2F19%2Fhexo-setting%2F</url>
    <content type="text"><![CDATA[在使用hexo+GitHub搭建个人博客的时候可以参考这个链接，和这个链接在这篇文章中作者详细介绍了搭建博客的详细过程，我写这片博客主要是以后迁移方便，以及还有一些需要设置的地方。下面详细介绍： 本地环境配置需要软件搭建博客首先需要基本的环境与软件，分别是: Git Node.js hexo 网上关于这三种工具的安装有很多例子，并且在上面提到的连接里面也有介绍，本文就不多加叙说。 参考这个链接 主题配置Next主题配置hexo启动以后默认的主题是landscape，我这边选用Next主题，主要是因为这个主题看着美观大方。大部分的配置在参考文件中已经说明了，我这里只说一些需要注意的地方，以及高级的一些配置。 图片的存放于使用图片的使用只在基本上在三个地方使用，a.头像，b.支付图片，c.文章图片。 因为主题的配置文件_config.yml是在注意文件夹里面的一级目录，与source文件夹属于同一级别。但是，在配置图片的时候，图片的配置路径与source里面的目录是一致的 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在） 配置为：avatar: /uploads/avatar.png 或者 放置在 source/images/ 目录下配置为：avatar: /images/avatar.png 头像设置为圆形，且可以旋转设置头像:打开themes/next/_config.yml找到avatar: /uploads/images/avatar.jpg;其中images文件在themes/nextsource/uploads中,将你的头像图片放到images中,一般默认命名为avatar,记得改下后缀就可以了。 设置旋转效果:打开themes\next\source\css\_common\components\sidebar\sidebar-author.styl,添加以下注释代码: 1234567891011121314151617181920212223242526272829303132.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转时间 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125; img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 为首页文章添加阴影边框效果打开next\source\css\_custom\custom.styl文件,添加以下代码: 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 在每篇文章末尾统一添加“本文结束”标记效果如下: 实现方法如下: 在\themes\next\layout\_macro下新建 passage-end-tag.swig 文件,并添加以下代码： 1234567&lt;div&gt;&#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt; -------------本文结束&lt;i class="fa fa-heart"&gt;&lt;/i&gt;感谢阅读------------- &lt;/div&gt;&#123;% endif %&#125;&lt;/div&gt; 打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer （post-footer之前有两个DIV）之前添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 打开主题配置文件_config.yml在末尾添加以下字段： passage_end_tag: enabled: true 到此,就大功告成了. 实现文章字数统计和阅读预估时间效果如下: 实现方法如下: 在站点根目录下使用GitBash命令安装 hexo-wordcount插件: $ npm install hexo-wordcount –save 在全局配置文件_config.yml中激活插件: 12345ymbols_count_time: symbols: true time: true total_symbols: true total_time: true 在主题的配置文件_config.yml中进行如下配置: 1234567 ymbols_count_time: time_minutes: trueseparated_meta: trueitem_text_post: trueitem_text_total: trueawl: 4wpm: 275 到此,我们就实现了文章字数统计和预估时间的显示功能 集成gitalk评论系统集成gitalk系统参考这个链接 参考这个链接 hexo 配置与使用发表文章hexo主题配置好以后，就剩下发表文章了。打开命令行，定位到 xxx.github.io 目录下： 新建普通页面命名为hexo-setting $ hexo new hexo-setting 这时在_post文件夹下生成一个hexo-setting.md文件 新建文件夹，文件夹命名为tags $ hexo new page “tags” 这时在source目录下生成一个tags文件夹，且默认在此文件夹下生成 index.md 文件 基本配置简析hexo 默认有categories、tags等目录，但是在source目录下没有此文件夹，所以用使用categories时，要先使用`hexo new page “categories” 命令建立此文件夹，然后在默认的此文件夹下的index.md文件中添加一下内容： title: 所有分类 date: 2018-10-22 17:16:58 type: &quot;categories&quot; # 将页面的类型设置为 categories comments: false # 如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，设置为 false 同理于tags,只需要把categories换成tags就可。如果想在添加其他文件夹或者菜单的话，需要现在配置文件中配置菜单，然后建立文件夹，再去操作。 以上就是Hexo + Github 搭建博客的基本操作和一些有趣的配置，有问题欢迎评论哦！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
